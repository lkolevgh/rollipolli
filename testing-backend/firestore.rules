// Author: Kabir Kwatra <kabir@kwatra.me>
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Disable Rules
  	// match /{docunent=**} {
    //   allow read, write: if true;
    // }
    
    // Helper Functions
    function authed() {
      return request.auth.uid != null;
    }
    
    // Polls
    match /polls/{document} {
      // resource does not already exist
      function isNew() {
      	return resource == null;
      }
      // owner matches record
      function userOwned() {
      	return resource.data.ownerID == request.auth.uid;
      }
      // Transaction is and only is a newly created poll
      function isPoll() {
        let requiredFields = ['ownerID', 'question', 'options', 'votes', 'createdAt', 'local'];
      	return request.resource.data.keys().toSet() == requiredFields.toSet() && // Fields match
              request.resource.data.ownerID == request.auth.uid &&  //  ownerID in poll data matches auth uid
              request.resource.data.question is string &&
              request.resource.data.question != "" &&
              request.resource.data.options is list &&
              request.resource.data.options.size() >= 2 && // at least 2 options
              request.resource.data.votes is map &&
              request.resource.data.votes.size() == 0 && // no inital votes
              request.resource.data.createdAt == request.time &&
              request.resource.data.local is bool;
      }
      // Transaction is and only is a vote
      function isVote() {
      	let dataDiff = request.resource.data.diff(resource.data);
      	return dataDiff.affectedKeys().hasOnly(['votes']) && // only thing changed is votes
               request.resource.data.votes is map &&
               request.auth.uid in request.resource.data.votes && // vote is counted when uid matches
               request.resource.data.votes.diff(resource.data.votes).affectedKeys().size() == 1 && // only one vote made
               request.resource.data.votes[request.auth.uid] is int &&
               request.resource.data.votes[request.auth.uid] >= 0 && // vote in bounds
               request.resource.data.votes[request.auth.uid] < resource.data.options.size();
      }
      match /{parentPath=**}/comments/{commentID} {
        function isComment() {
          return exists(debug(/databases/$(database)/documents/polls/$(document)/$(parentPath))) &&
            request.resource.data.keys().toSet() == ['author', 'createdAt', 'content'].toSet() &&
            request.resource.data.author == request.auth.uid &&
            request.resource.data.createdAt == request.time &&
            request.resource.data.content is string &&
            request.resource.data.content != "";
        }
        allow read: if authed();
        allow create: if authed() && isNew() && isComment();
        allow delete: if authed() && request.userID == resource.data.author;
      }
      allow read: if authed();
      allow create: if authed() && isNew() && isPoll();
      allow delete: if authed() && userOwned();
      allow update: if authed() && !isNew() && isVote();
    }
    
    // User Data
  	match /users/{userID} {
      function isAllowedUpdate() {
        return isVote()
            || (request.resource.data.keys().toSet() == ['emoji'].toSet()
             && request.resource.data.emoji is string
             && ownsEmoji(request.resource.data.emoji))
            || (request.resource.data.keys().toSet() == ['innerColor'].toSet() && request.resource.data.innerColor is int)
            || (request.resource.data.keys().toSet() == ['outerColor'].toSet() && request.resource.data.outerColor is int);
      }
      function isVote() {
        return (request.resource.data.keys().toSet() == ['votedOnPolls']
             && request.resource.data.votedOnPolls.size() == 1 // only one poll
             && !(request.resource.data.votedOnPolls[0] in resource.data.votedOnPolls) // poll does not already exist
             && exists(request.resource.data.votedOnPolls[0])
             )
      }
      // TODO: Verify user owns emoji by seeing if emoji in resource.data.ownedEmojis
      function ownsEmoji(emoji) {
        return true;
      }
      allow read: if authed();
      allow update, create: if authed() && request.auth.uid == userID && isAllowedUpdate();
    }
  }
}